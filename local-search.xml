<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2022秋招记录</title>
    <link href="/2021/09/30/2022%E7%A7%8B%E6%8B%9B%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/09/30/2022%E7%A7%8B%E6%8B%9B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>从 9 月 8 号开始，我已经为秋季校招准备了三周的笔试和面试，说实话学的不咋地。按理说应该要准备三个月的，但奈何之前光玩去了，完全没考虑应聘的事情。不过无所谓了，这次就先试试吧，能找到最好，找不到也不慌。只投北京和上海，能过笔试就算成功！🤣</p><h2 id="想去的公司"><a href="#想去的公司" class="headerlink" title="想去的公司"></a>想去的公司</h2><table><thead><tr><th align="center">公司</th><th align="center">地点</th><th align="center">投递时间</th><th align="center">简历</th><th align="center">笔试</th><th align="center">一面</th></tr></thead><tbody><tr><td align="center">鹰角网络</td><td align="center">上海</td><td align="center">2021/9/30</td><td align="center">筛选中</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">心动网络</td><td align="center">上海</td><td align="center">2021/9/30</td><td align="center">✅</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">叠纸游戏</td><td align="center">上海</td><td align="center">2021/9/30</td><td align="center">筛选中</td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="海投公司"><a href="#海投公司" class="headerlink" title="海投公司"></a>海投公司</h2><table><thead><tr><th align="center">公司</th><th align="center">地点</th><th align="center">投递时间</th><th align="center">简历</th><th align="center">笔试</th><th align="center">一面</th></tr></thead><tbody><tr><td align="center">友塔游戏</td><td align="center">上海</td><td align="center">2021/9/30</td><td align="center">筛选中</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Garena</td><td align="center">上海</td><td align="center">2021/9/30</td><td align="center">筛选中</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">祖龙娱乐</td><td align="center">上海</td><td align="center">2021/9/30</td><td align="center">筛选中</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">乐元素</td><td align="center">北京</td><td align="center">2021/9/30</td><td align="center">✅</td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】55. 跳跃游戏</title>
    <link href="/2021/09/14/%E3%80%90LeetCode%E3%80%9155-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <url>/2021/09/14/%E3%80%90LeetCode%E3%80%9155-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p class="note note-success">题目来源：<a href="https://leetcode-cn.com/problems/jump-game/">力扣 LeetCode 55. 跳跃游戏</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p><p>示例 1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳<span class="hljs-number"> 1 </span>步，从下标<span class="hljs-number"> 0 </span>到达下标 1, 然后再从下标<span class="hljs-number"> 1 </span>跳<span class="hljs-number"> 3 </span>步到达最后一个下标。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：无论怎样，总会到达下标为 <span class="hljs-number">3</span> 的位置。但该下标的最大跳跃长度是 <span class="hljs-number">0</span> ， 所以永远不可能到达最后一个下标。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从第一个元素开始，找到它在数组中的活动范围，然后在这个范围内找是否有更大的范围。如果这个最大范围可以到达最后一个元素，则返回 <code>true</code>，如果遍历的元素下标超过了这个最大范围，说明无法到达最后一个元素，返回 <code>false</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, maxNum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-comment">// 如果只有一个元素，肯定能到达</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n &amp;&amp; i &lt;= maxNum;i++) &#123;<br>            maxNum = <span class="hljs-built_in">max</span>(nums[i]+i, maxNum);<br>            <span class="hljs-keyword">if</span>(maxNum &gt;= n)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(<em>n</em>)。只需要遍历一次长度为 n 的 <code>nums</code> 数组。</li><li>空间复杂度：O(1)。只需要额外的常数空间。</li></ul>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】42. 接雨水</title>
    <link href="/2021/09/14/%E3%80%90LeetCode%E3%80%9142-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2021/09/14/%E3%80%90LeetCode%E3%80%9142-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<p class="note note-success">题目来源：<a href="https://leetcode-cn.com/problems/trapping-rain-water/">力扣 LeetCode 42. 接雨水</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>示例 1：</p><p><img src="https://i.loli.net/2021/09/14/Jv4wASRkCMLc6dW.png"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><img src="https://i.loli.net/2021/09/14/pzrCJBvWZnI6x5b.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = height.<span class="hljs-built_in">size</span>(), sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">leftMax</span><span class="hljs-params">(n)</span>, <span class="hljs-title">rightMax</span><span class="hljs-params">(n)</span></span>;<br>        leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++)<br>            leftMax[i] = <span class="hljs-built_in">max</span>(leftMax[i<span class="hljs-number">-1</span>], height[i]);<br>        rightMax[n<span class="hljs-number">-1</span>] = height[n<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n<span class="hljs-number">-2</span>;i &gt;= <span class="hljs-number">0</span>;i--)<br>            rightMax[i] = <span class="hljs-built_in">max</span>(rightMax[i+<span class="hljs-number">1</span>], height[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)<br>            sum += <span class="hljs-built_in">min</span>(leftMax[i], rightMax[i]) - height[i];<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(<em>n</em>)。遍历 3 次数组，但没有嵌套 for 循环。</li><li>空间复杂度：O(<em>n</em>)。需要两个额外的长度为 n 的数组。</li></ul><h2 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>设两个指针，一个从左往右，另一个从右往左，然后比较两者大小。如果左边比右边小，则说明从这一格开始往右的水的高度都由左边最高的柱子控制，直到左边有柱子比右边的高为止，反之亦然。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, maxLeft = <span class="hljs-number">0</span>, maxRight = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            maxLeft = <span class="hljs-built_in">max</span>(maxLeft, height[left]);<br>            maxRight = <span class="hljs-built_in">max</span>(maxRight, height[right]);<br>            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])<br>                sum += maxLeft - height[left++];<br>            <span class="hljs-keyword">else</span><br>                sum += maxRight - height[right--];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(<em>n</em>)。只有一个 while 循环，左右指针一共移动了 n 次。</li><li>空间复杂度：O(1)。只需要额外的常数空间。</li></ul>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>动态规划</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【LeetCode】300. 最长递增子序列</title>
    <link href="/2021/09/14/%E3%80%90LeetCode%E3%80%91300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/09/14/%E3%80%90LeetCode%E3%80%91300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p class="note note-success">题目来源：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">力扣 LeetCode 300. 最长递增子序列</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p>示例 1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[0,1,0,3,2,3]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,7,7,7,7,7,7]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>每个元素自己就是一个长度为 1 的子序列，若要与前面某个子序列结合，只需要在前面的子序列长度上 <code>+1</code> 即可。建立一个数组 <code>len</code>，下标与数组 <code>nums</code> 对应，用于储存每个元素与前面的子序列形成的最长递增子序列长度，公式为 <code>len[i] = max(len[j]) + 1</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>(), maxNum = <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">len</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 每个元素形成的子序列长度至少为 1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; i;j++) <span class="hljs-comment">// 比较前面的每一个子序列长度</span><br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j]) &#123;<br>                    len[i] = <span class="hljs-built_in">max</span>(len[j]+<span class="hljs-number">1</span>, len[i]);<br>                    maxNum = <span class="hljs-built_in">max</span>(len[i], maxNum);<br>                &#125;<br>        <span class="hljs-keyword">return</span> maxNum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(<em>n</em><sup>2</sup>)。两个嵌套 for 循环，都遍历 n 次。</li><li>时间复杂度：O(<em>n</em>)。需要额外的长度为 n 的数组 len。</li></ul><h2 id="方法二：贪心-二分查找"><a href="#方法二：贪心-二分查找" class="headerlink" title="方法二：贪心+二分查找"></a>方法二：贪心+二分查找</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>如果希望一个上升子序列尽可能的长，那么需要让它上升得尽可能慢。建立一个数组 <code>arr</code>，先将 <code>nums</code> 的第一个元素存入，然后向后遍历 <code>nums</code>。如果元素大于 <code>arr</code> 的最后一个元素，则将它加在 <code>arr</code> 的最后面；如果小，则通过二分查找找到 <code>arr</code> 里第一个比它大的元素，然后进行替换。</p><p>原理：不管怎么替换元素，<code>arr</code> 的长度始终不变，当最后一个元素被替换成更小的时，就更容易让后面稍大的元素加到 <code>arr</code> 的后面，从而增加 <code>arr</code> 的长度。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>(), len = <span class="hljs-number">1</span>; <span class="hljs-comment">// len 是最长子序列长度</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(n)</span></span>;<br>        arr[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 放入第一个元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; arr[len<span class="hljs-number">-1</span>])<br>                arr[len++] = nums[i];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] &lt; arr[len<span class="hljs-number">-1</span>]) &#123;<br>                <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = len<span class="hljs-number">-1</span>, num = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>                    <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">if</span>(nums[i] &gt; arr[mid]) &#123;<br>                        num = mid+<span class="hljs-number">1</span>;<br>                        left = mid+<span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                        right = mid<span class="hljs-number">-1</span>;<br>                &#125;<br>                arr[num] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(<em>n</em>log<em>n</em>)。for 循环遍历 n 次是 O(<em>n</em>)，二分查找是 O(log<em>n</em>)。</li><li>空间复杂度：O(<em>n</em>)。需要额外的长度为 n 的数组 arr。</li></ul>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十大排序算法</title>
    <link href="/2021/09/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2021/09/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h2><p>冒泡排序是从第一个元素开始和后面相邻的元素进行比较，如果后面元素大则交换，直到将最大的元素放到数组最后，然后剩余元素再重复此过程。</p><p><img src="https://i.loli.net/2021/09/14/4AltIK9pPEGfmOj.gif" alt="冒泡排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = num<span class="hljs-number">-1</span>;i &gt; <span class="hljs-number">0</span>;i--)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; i;j++)<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])<br>                <span class="hljs-built_in">swap</span>(arr[j], arr[j+<span class="hljs-number">1</span>]);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">24</span>,<span class="hljs-number">15</span>,<span class="hljs-number">2</span>,<span class="hljs-number">75</span>,<span class="hljs-number">4</span>,<span class="hljs-number">97</span>,<span class="hljs-number">66</span>,<span class="hljs-number">23</span>,<span class="hljs-number">10</span>,<span class="hljs-number">46</span>&#125;;<br><span class="hljs-built_in">bubbleSort</span>(arr, <span class="hljs-number">10</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)<br><span class="hljs-built_in">printf</span>((i == <span class="hljs-number">9</span>)?<span class="hljs-string">&quot;%d\n&quot;</span>:<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、选择排序（Select-Sort）"><a href="#2、选择排序（Select-Sort）" class="headerlink" title="2、选择排序（Select Sort）"></a>2、选择排序（Select Sort）</h2><h2 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h2><p>插入排序是从第二个元素开始，向前找到合适的位置，然后插进去，完成后，再从下一个元素开始向前找，直到找完最后一个。</p><p><img src="https://i.loli.net/2021/09/14/aWkmb4LtX3uwUQM.gif" alt="插入排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> num)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i, j, tmp;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt; num;i++) &#123;<br>tmp = arr[i];<span class="hljs-comment">// 要执行插入操作的数</span><br><span class="hljs-keyword">for</span>(j = i;j &gt; <span class="hljs-number">0</span> &amp;&amp; tmp &lt; arr[j<span class="hljs-number">-1</span>];j--)<br>arr[j] = arr[j<span class="hljs-number">-1</span>];<span class="hljs-comment">// 若数大于 tmp，则向后移一位</span><br>arr[j] = tmp;<span class="hljs-comment">// 将 tmp 填到空出的位置上</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">24</span>,<span class="hljs-number">15</span>,<span class="hljs-number">2</span>,<span class="hljs-number">75</span>,<span class="hljs-number">4</span>,<span class="hljs-number">97</span>,<span class="hljs-number">66</span>,<span class="hljs-number">23</span>,<span class="hljs-number">10</span>,<span class="hljs-number">46</span>&#125;;<br><span class="hljs-built_in">insertSort</span>(arr, <span class="hljs-number">10</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)<br><span class="hljs-built_in">printf</span>((i == <span class="hljs-number">9</span>)?<span class="hljs-string">&quot;%d\n&quot;</span>:<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h2><h2 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h2><h2 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h2><p>快速排序是以一个元素为基准，小的元素放左边，大的元素放右边，然后再用递归从左右两边重复此过程。基准可以是任意一个元素，但为了防止遇到最坏的情况（比如每次都选最小或最大的元素作为基准），所以一般随机取一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-built_in">rand</span>()%(right-left+<span class="hljs-number">1</span>)+left;   <span class="hljs-comment">// 取一个随机数</span><br>    <span class="hljs-built_in">swap</span>(arr[left], arr[mid]);  <span class="hljs-comment">// 将随机取出来的元素和最左边的元素交换</span><br>    mid = arr[left];<br>    <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= mid)<br>            right--;<br>        arr[left] = arr[right]; <span class="hljs-comment">// 先用右边的元素覆盖左边，因为左边第一个元素有记录</span><br>        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= mid)<br>            left++;<br>        arr[right] = arr[left];<br>    &#125;<br>    arr[left] = mid;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-built_in">sort</span>(arr, left, right);<br>    <span class="hljs-built_in">quickSort</span>(arr, left, mid<span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">quickSort</span>(arr, mid+<span class="hljs-number">1</span>, right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">24</span>,<span class="hljs-number">15</span>,<span class="hljs-number">2</span>,<span class="hljs-number">75</span>,<span class="hljs-number">4</span>,<span class="hljs-number">97</span>,<span class="hljs-number">66</span>,<span class="hljs-number">23</span>,<span class="hljs-number">10</span>,<span class="hljs-number">46</span>&#125;;<br><span class="hljs-built_in">quickSort</span>(arr, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)<br><span class="hljs-built_in">printf</span>((i == <span class="hljs-number">9</span>)?<span class="hljs-string">&quot;%d\n&quot;</span>:<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h2><h2 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h2><p>计数排序是找出数组中的最大元素和最小元素，然后生成大小为 (max-min+1)  的数组，并对所有的元素计数，最后从头到尾根据数量返回。</p><p><img src="https://i.loli.net/2021/09/14/3DGVuzPBUEer7HQ.gif" alt="计数排序"></p><h2 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h2><p>桶排序是计数排序的升级版，它将 max 与 min 之间均分，然后将元素放到不同的桶中，再对每个桶进行排序。</p><p><img src="https://z3.ax1x.com/2021/09/13/4Ptc5t.png" alt="桶排序"></p><h2 id="10、基数排序（Radix-sort）"><a href="#10、基数排序（Radix-sort）" class="headerlink" title="10、基数排序（Radix sort）"></a>10、基数排序（Radix sort）</h2><p>基数排序也用到了桶的概念，它先根据元素的个位将它们放入 0-9 对应的桶中，再在其余的高位重复此过程。</p><p><img src="https://i.loli.net/2021/09/14/DojMIK8fmB4VklT.gif" alt="基数排序"></p>]]></content>
    
    
    <categories>
      
      <category>知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Re: Blog</title>
    <link href="/2021/09/12/Re-Blog/"/>
    <url>/2021/09/12/Re-Blog/</url>
    
    <content type="html"><![CDATA[<p>今天我又双叒叕建了个博客，这是我大学以来第四个博客，用的是 GitHub Pages + Hexo。</p><p>我从大一寒假就开始折腾博客了，那个时候参加学校的 ACM 社团，正好喜欢这玩意儿，也学的挺好，就想着模仿学长用 GitHub 建个博客，在上面写自己的做题心得。然而也许是因为技术力不够，也没什么耐心，我看着教程一步步弄也没弄好。后来在研究如何建博客的时候，我对此产生了怀疑：我为什么要建博客呢？对啊，为什么要建？为了给自己看？可我都会了，为什么还要看呢？为了给别人看？那为什么不直接在 CSDN 写，自建博客有多大概率会被人搜到呢？emmm……在一阵子自我怀疑后，我放弃了，因为我觉得博客没用。</p><p>后来到了大一快结束时，也就是 2018 年 6 月，我又想建博客了。不过这次我没有继续研究 Github，而是选择了简单的 WordPress，可以直接建站的那个。在短暂的设置后，我的博客（<a href="https://zfygenius.wordpress.com/">https://zfygenius.wordpress.com/</a>）建成了。因为那个时候我已经退出了 ACM 社团，不再做题了，所以一时不知道该往博客里写些什么，后来把自己的一次编程作业的代码贴了上去，又写了一篇软件推荐，然后就不了了之了。</p><p><img src="https://i.loli.net/2021/09/14/wtpQ3EYNSaHu1dh.png" alt="第一个博客——WordPress"></p><p>2018 年底，我当时在做一个网页制作的期末项目，UI 模仿了<a href="https://moe.best/">神代綺凛</a>的博客，由于每天都要找出它来参考一下，所以那段时间我又萌发了建博客的想法。于是在做完网页项目后，我再次研究了一下如何用 GitHub 建博客，最终建成功了（<a href="https://gfkgfkgfk.github.io/">https://gfkgfkgfk.github.io/</a>）。不过这个博客也没写什么东西，第一篇博文简单叙述了一下建站过程，第二篇详细说了一下网页的制作过程，然后就没后续了。那个网页的制作过程我当时写的挺用心的，所以现在将它搬到了这个博客底下，就当作留念了。不过我在搬这篇文章时发现存在 GitHub 里的图片全都不显示了，难道现在没法当作图床了？也正是因为这篇文章的图片没了，所以我这次不敢再将 GitHub 当作图床，而是选择了 <a href="https://sm.ms/">SM.MS</a> 和<a href="https://imgtu.com/">路过图床</a>混用。</p><p><img src="https://i.loli.net/2021/09/14/GrevyQlHxdCwBJu.png" alt="第二个博客——Github Pages"></p><p>大二寒假，我从网上得知了 Blogger 这个免费且有较高自由度的博客网站，在浏览了它的一些主题后，我觉得值得一试，于是第三个博客就建好了（<a href="https://fy-zhang.blogspot.com/">https://fy-zhang.blogspot.com/</a>）。这个博客我当时真的挺喜欢的，所以还把之前写过的两篇文章迁移了过来。同时，我发现近一年没做 ACM 题的我对链表有些生疏了，便从学校 OJ 上找到了自己当时编的程序，放到了”OJ 精选“页面里。有意思的是，这个”主页“和”OJ 精选“（<a href="https://fy-zhang-oj.blogspot.com/">https://fy-zhang-oj.blogspot.com/</a>）其实是两个网站，Blogger 有个功能可以在那一行添加网站，我就正好利用这一点比它们伪装成了两个页面 23333。</p><p><img src="https://i.loli.net/2021/09/14/6uEbz4AfXp5YcHs.png" alt="第三个博客——Blogger"></p><p>大二结束后，我就再也没用过博客，对它彻底失去了兴趣。而我今天再次将它捡起来的原因，是因为我见到棺材落了泪，发现博客的真正用途了。</p><p>我现在大四毕业，之前因为申请上了利兹大学的研究生，所以完全没打算找工作，但快毕业时我又不想去了，目前是学业工作两手空，就很慌。我现在在准备秋招的笔试和面试，这几天做 LeetCode 和看面经时我发现，想要在大城市或大公司找到工作还是挺难的。笔试考的是数据结构和算法，这玩意儿我大一倒是会，但现在早忘了。看课本吧，内容太简单，我当时在 ACM 社团学到的东西也没往上面记；看算法书吧，上面的格式和我学的有些出入，短时间接受起来并不算容易；找找以前写过的程序吧，七零八落得谁知道对应程序在哪里！嗯，我后悔当初没有写博客了，就算我只将当时写的程序记上去，也比看不熟悉的代码风格要容易。比如这个大一寒假写的<a href="https://paste.ubuntu.com/26503353/">归并排序</a>，真的是一看就明白了。😂</p><p>这个博客目前的作用是整理一下近期学习的知识点，到时候面试前可以快速翻出来看，以后大概也会坚持下去吧，毕竟已经吃到了一次苦头。现在我开始刷 LeetCode 了，不管是否找到工作，我都打算一直刷下去，遇到有意思的题目我也会写到博客上来的！</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【作业】电子商务架构 Final Project</title>
    <link href="/2018/12/27/%E3%80%90%E4%BD%9C%E4%B8%9A%E3%80%91%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E6%9E%B6%E6%9E%84-Final-Project/"/>
    <url>/2018/12/27/%E3%80%90%E4%BD%9C%E4%B8%9A%E3%80%91%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E6%9E%B6%E6%9E%84-Final-Project/</url>
    
    <content type="html"><![CDATA[<p class="note note-success">文章搬运自 <a href="https://gfkgfkgfk.github.io/2018/12/27/Final-Project-%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/">Final Project 制作过程 - 张峰源的博客 | ZFY Blog</a></p><p>这是我编写的第一个“大型程序”，集中敲了三天半代码，后来又断断续续增加了一些页面。</p><p>本次制作主要参考了<a href="https://moe.best/">神代綺凜の萌化小基地</a>、<a href="http://www.runoob.com/">菜鸟教程</a>、<a href="http://www.w3school.com.cn/index.html">W3school</a>，以及其他的一些博客。</p><p>美术不好的我制作网页最头疼的地方就是 CSS，由于是期末作业，所以模板什么的不能找，那就借鉴一下别人的吧！于是找到了神代绮凛的 Blog，照着它的样式、颜色做了一个网页出来。虽然由于技术原因，未能将他的 Blog 完美重现，但依然解决了我最为头疼的问题。</p><p><img src="https://i.loli.net/2021/09/14/KuU9YdvhzGX2cSg.jpg" alt="好看就行了，管它像不像呢 (￣▽￣)"></p><p>在 “Contact” 页面中，老师让我们附上地图，这个地图肯定不是普通的截图，所以我就去网上搜了一下如何插入地图，这里参考了<a href="https://blog.csdn.net/wyl1401672169/article/details/79021112">js调用百度地图接口实现定位功能</a>，用到了<a href="http://lbsyun.baidu.com/index.php?title=jspopular">百度地图JS API</a>。代码复制上去之后改改就可以用了，所以我也没有去深究它的含义23333。</p><p><img src="https://i.loli.net/2021/09/14/CGN1lEtfjVPsz2X.gif" alt="百度地图JS API"></p><p>做完这些基础的 HTML 页面后，我开始制作真正需要 PHP 的页面，就是上方那一条的右边四个按钮。</p><p>我首先做的是 “Animation” 页面，因为我要在这个页面中显示出动漫的详细信息，所以需要用到数据库。这里我为了在表中存入中文，参考了<a href="https://www.jb51.net/article/147131.htm">mysql中插入表数据中文乱码问题的解决方法</a>，为了更方便地往数据库中存入数据，参考了<a href="https://blog.csdn.net/qq_36832411/article/details/76619663">如何使用mysql导入txt数据</a>。</p><p><img src="https://i.loli.net/2021/09/14/pOsCQVMa8RjSYLN.gif" alt="动画信息数据库"></p><p>建立完数据库后，我利用 PHP 连接数据库，读取里面的动漫名(Name)和图片地址(Cover)，然后将它们平铺在网页上。有两季及以上的动画自动在名字后面加上第几季，只有一季的只显示动画名，这里我用非常简单粗暴的 for 循环判断是否只有一季，肯定有更好的办法，但我暂时还想不到。于是，”Animation” 页面就做成了这个样子：</p><p><img src="https://i.loli.net/2021/09/14/PpzQ4Ax2O1H6U5y.jpg" alt="Animation 页面"></p><p>接下来是登录、注册和登出，我参考了<a href="https://www.cnblogs.com/leinov/p/3745401.html">php注册登录系统</a>和<a href="https://zhidao.baidu.com/question/1882548854151467788.html">php判断用户是否登录</a>，稍微改了改里面的代码，然后作为自己的，很轻松就弄出来了。登出的话我将它设定为点击名字后跳转到一个页面，然后那里有清除 SESSION 的代码。登录时的条款条件和隐私政策我照搬了<a href="https://www.pythonanywhere.com/">Python Anywhere</a>的条款(￣ε(#￣)☆╰╮o(￣皿￣///)</p><p><img src="https://z3.ax1x.com/2021/09/12/492HZ6.jpg" alt="注册和登录"></p><p>最后是 “My Favorite”，这个页面的作用是显示用户喜欢的动画，本来想的是将 “User” 和 “Information” 这两个数据库连接一下，结果（因技术不够出现的结果又出现了！）连接不成功，只能将喜欢的动画信息再在 “User” 里存一遍了。问题很多，但好歹是实现了~</p><p>做完基础页面，我开始做每个动画的详细信息页面，以 “Cover” 作连接，用 PHP 实现了精准跳转(～￣▽￣)～</p><p><img src="https://i.loli.net/2021/09/14/TOtNeZ2qymoad6p.jpg" alt="Information - 《中二病也要谈恋爱》"></p><p>最后来张代码合影👇</p><p><img src="https://i.loli.net/2021/09/14/JQZgOibHTCnqaAh.gif" alt="Code"></p><p>点击这里查看代码👉<a href="https://github.com/FY-Zhang/2018-12-Final-Project">2018-12-Final-Project</a></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
